&lt;?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title>npalladium</title><link href="/blog/atom.xml" rel="self" type="application/atom+xml"/><link href="/blog/" rel="alternate" type="text/html"/><id>/blog/</id><updated>2026-02-28T13:03:45Z</updated><author><name>n</name></author><entry><title>Autocorrect helps unravel what little is left of my sanity</title><link href="/blog/post/autocorrect/" rel="alternate" type="text/html"/><id>/blog/post/autocorrect/</id><updated>2026-02-28T18:33:33+05:30</updated><published>2026-02-28T18:33:33+05:30</published><author><name>npalladium</name></author><content type="html">&lt;![CDATA[<p>
I’m the world’s most frustrated man,<br>
My brain is fried, my thumbs are weak.<br>
I thought more AI would solve my problem,<br>
But now the outlook’s rather bleak.<br>
Give me a pen, a piece of paper,<br>
A stick, a rock, a bit of clay;<br>
The duck king Autocorrect never understood,<br>
The things I actually wanted to say.</p><hr><p>Omakes:</p><p>
&gt; I thought more AI would solve my problem,<br>
&gt; But it crushes the words I speak.</p><p>
&gt; I thought more AI would solve my problem,<br>
&gt; But my Microsoft Outlook is now bleak.</p>
]]></content></entry><entry><title>Scripting For Profit</title><link href="/blog/post/bash/" rel="alternate" type="text/html"/><id>/blog/post/bash/</id><updated>2026-02-28T18:20:31+05:30</updated><published>2026-02-28T18:20:31+05:30</published><author><name>npalladium</name></author><category term="bash"/><category term="shell"/><category term="programming"/><content type="html">&lt;![CDATA[<div id="outline-container-headline-1" class="outline-2"><h2 id="headline-1">
Scripting?</h2><div id="outline-text-headline-1" class="outline-text-2"><p>Scripts are everywhere, from doing backups of your DB server to S3, listing all the namespaces in a Kubernetes cluster without pods, or simply bootstrapping your environments. A day doesn't go by without writing a new script or at least executing a script I wrote before.</p><p>
Scripts make life easier. They save time on repetitive tasks. They are ubiquitous.</p><p>
Having been writing scripts for a while<sup class="footnote-reference"><a id="footnote-reference-1" href="#footnote-1">1</a></sup>, I wanted to write an article to:</p><ul><li>pen my thoughts and opinions on scripting<sup class="footnote-reference"><a id="footnote-reference-2" href="#footnote-2">2</a></sup> for "production" (after all, the article is titled "…For Profit");</li><li>maybe help others (including my future self) by documenting some good scripting hygiene and common pitfalls in one place.<sup class="footnote-reference"><a id="footnote-reference-3" href="#footnote-3">3</a></sup></li></ul></div></div><div id="outline-container-headline-2" class="outline-2"><h2 id="headline-2">
Shell Scripting on Linux</h2><div id="outline-text-headline-2" class="outline-text-2"><p>If you are writing scripts on Linux, you are probably writing them in a Shell scripting language (Bash, mostly). Even if you've used Python, Ruby, or Node, you've probably still written a Shell script or ten—either out of convenience, or because nothing else was available. The appeal of scripting in Shell probably comes from how you use the same constructs in the interactive commands you run in the Terminal and how easy it is to glue several commands together.</p><p>
The gluing constructs shell provides (everything-as-text and pipes) mean that if your program is oriented around "commands", nothing beats it<sup class="footnote-reference"><a id="footnote-reference-4" href="#footnote-4">4</a></sup><sup class="footnote-reference"><a id="footnote-reference-5" href="#footnote-5">5</a></sup>. Shell is an excellent Domain Specific Language that is failure tolerant (to a fault) and concise (again to a fault).</p></div></div><div id="outline-container-headline-3" class="outline-2"><h2 id="headline-3">
Bashing Bash</h2><div id="outline-text-headline-3" class="outline-text-2"><p>There are several excellent reasons not to use Bash. Some of the oft-cited reasons are:</p><ul><li><strong>It is stringly-typed:</strong> Almost all bash variables are strings.</li><li><strong>Arcane incantations:</strong> Bash usage is full of abstruse invocations like<code class="verbatim">$*</code>,<code class="verbatim">$#</code>, and<code class="verbatim">&lt;()</code> (<a href="https://www.gnu.org/software/bash/manual/html_node/Process-Substitution.html">process substitution</a>). Short arguments and obscure built-ins are both hard to read and hard to google.</li><li><strong>Awkward syntax:</strong> The syntax differs significantly from other popular languages.</li><li><strong>Have to use tools:</strong> Bash doesn't have a standard library; it relies on external tools, which can be inefficient and inconsistent across systems.</li><li><p><strong>Environments can differ:</strong> The tools you want may not be installed on your target system, or a subtly different version may behave unexpectedly.</p><ul><li>BSD vs GNU anyone?<sup class="footnote-reference"><a id="footnote-reference-6" href="#footnote-6">6</a></sup></li></ul></li></ul></div></div><div id="outline-container-headline-4" class="outline-2"><h2 id="headline-4">
Why use Bash?</h2><div id="outline-text-headline-4" class="outline-text-2"><ul><li><strong>Ubiquitous:</strong> Bash is available in almost all Linux environments.
(Even if Bash isn't available, a POSIX-compliant shell likely is.)</li><li><strong>Powerful:</strong> Pipes and the Unix culture of small, composable tools make
everyday automation easy.</li></ul></div></div><div id="outline-container-headline-5" class="outline-2"><h2 id="headline-5">
Better Bash</h2><div id="outline-text-headline-5" class="outline-text-2"><div id="outline-container-headline-6" class="outline-3"><h3 id="headline-6">
When not to use Bash</h3><div id="outline-text-headline-6" class="outline-text-3"><p>A part of writing good Bash scripts is knowing when to reach for other
tools<sup class="footnote-reference"><a id="footnote-reference-7" href="#footnote-7">7</a></sup>. Consider something other than Bash when:</p><ul><li>Your script is longer than a few hundred lines.</li><li>You need rich data structures like hash-maps or nested lists.</li><li>You have a hard time working around quoting issues.</li><li>You do a lot of string manipulation or arithmetic.</li><li>You do not have much need for invoking other programs or pipelining them.</li><li>You worry about performance or need complex control flow (e.g. nested loops).</li></ul><p><strong>What to use instead:</strong></p><ul><li><strong>Python:</strong> Great syntax and standard library; lacks native YAML support (a pain for DevOps).</li><li><strong>Ruby:</strong> Has YAML in the standard library and elegant shell integration. Best when you control all target systems.</li><li><strong>Perl:</strong> Powerful text processing; less common today.</li><li><strong>zx / bun shell:</strong> JavaScript-based scripting with a modern feel.</li><li><strong>Golang:</strong> Excellent for distributing statically compiled binaries that run anywhere.</li><li><strong>Language of your choice:</strong> People have used<a href="https://bitfieldconsulting.com/golang/scripting">Go</a>,<a href="https://github.com/rust-shell-script/rust_cmd_lib">Rust</a>,<a href="https://zignar.net/2021/07/09/why-haskell-became-my-favorite-scripting-language/">Haskell</a><sup class="footnote-reference"><a id="footnote-reference-8" href="#footnote-8">8</a></sup>,<a href="https://bellard.org/tcc/">C</a>, and<a href="https://www.jbang.dev/">Java</a><sup class="footnote-reference"><a id="footnote-reference-9" href="#footnote-9">9</a></sup> for scripting.</li><li><p>Alternative shells: There are also alternative shells worth knowing about, though I don't personally reach for them — if I'm installing a new tool anyway, I'd rather switch to a full language.</p><ul><li><a href="https://www.nushell.sh/">Nushell</a> treats pipeline output as structured data — tables and typed values — rather than raw text, so you can write<code class="verbatim">select login contributions</code> instead of piping through<code class="verbatim">jq</code>.</li><li><a href="https://www.oilshell.org/">Oil Shell</a> takes a compatibility-first approach: its OSH mode runs existing Bash scripts as-is, while YSH layers a cleaner language on top, giving a gentler migration path for legacy scripts.</li></ul></li></ul><p>If I want to replace a bash script, I use Python, Ruby, or Golang. Python is my first choice unless I have to deal with YAML; in that case I use Ruby (for scripts that only run on systems I control) or Golang (for anything else, since I can hand out statically compiled binaries).</p><p><strong>Some reasons you may still prefer Bash:</strong></p><ol><li>You are largely dealing with filesystem operations such as moving, copying, and deleting.</li><li>You are gluing external CLI tools.</li><li>You are building something iteratively and pipes are amazing.</li><li>You cannot guarantee the presence of anything other than a POSIX Shell.</li></ol><p><strong>Alternatives to consider:</strong></p><ul><li>Gluing kubectl commands? Consider whether a Golang library or kubectl plugin is worthwhile.</li><li>Building iteratively? Look at Notebooks and REPLs.<sup class="footnote-reference"><a id="footnote-reference-10" href="#footnote-10">10</a></sup></li><li>Writing an installation script? Have a binary do the actual installation; the shell script just figures out the version to download and runs it.</li></ul></div></div><div id="outline-container-headline-7" class="outline-3"><h3 id="headline-7">
Questions to ask yourself</h3><div id="outline-text-headline-7" class="outline-text-3"><ul><li><strong>How often is this used?</strong> (Throwaway vs. production)</li><li><strong>Who is using it?</strong> (Just me vs. the whole team)</li><li><strong>Where is it running?</strong> (CI/CD vs. legacy bare metal)</li><li><strong>Is this script meant to be run by humans?</strong></li><li><strong>What happens if it fails?</strong> (Minor blip vs. production outage)</li></ul></div></div><div id="outline-container-headline-8" class="outline-3"><h3 id="headline-8">
General Programming Hygiene</h3><div id="outline-text-headline-8" class="outline-text-3"><ul><li><p><strong>Modularity:</strong> Use<code class="verbatim">source</code> to pull in external configs or functions.</p><ul><li>As a personal preference, I tend not to split anything less than 100 lines, unless I need reusable functionality.</li></ul></li><li><strong>Functions:</strong> Group logical steps. Keep the global scope clean.</li><li><p><strong>Readonly &amp; Local:</strong> Use<code class="verbatim">local</code> inside functions and a top level<code class="verbatim">readonly</code> for constants. Combine them with<code class="verbatim">local -r</code> (a Bashism) for variables in functions that should be set once and never mutated:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">process<span class="o">()</span><span class="o">{</span></span></span><span class="line"><span class="cl"><span class="nb">local</span> -r<span class="nv">input_file</span><span class="o">=</span><span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span></span></span><span class="line"><span class="cl"><span class="nb">local</span> result</span></span><span class="line"><span class="cl"><span class="nv">result</span><span class="o">=</span><span class="k">$(</span>compute<span class="s2">"</span><span class="nv">$input_file</span><span class="s2">"</span><span class="k">)</span></span></span><span class="line"><span class="cl"><span class="nb">echo</span><span class="s2">"</span><span class="nv">$result</span><span class="s2">"</span></span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div></div><ul><li><p>Bash uses a form of dynamic scoping, not lexical scoping —<code class="verbatim">local</code> variables are visible to any function called from within the declaring function. This creates two pitfalls worth knowing:</p><ul><li><strong>Silent mutation:</strong> If a child function uses the same variable name without declaring it<code class="verbatim">local</code>, it silently reads and writes the parent's variable. Always declare every variable<code class="verbatim">local</code> at the top of each function, even "obviously temporary" names like<code class="verbatim">i</code>,<code class="verbatim">line</code>, or<code class="verbatim">tmp</code>.</li><li><strong><code class="verbatim">local -r</code> scope bleed:</strong> A<code class="verbatim">readonly</code> local in a parent prevents any child function from declaring its own variable with the same name — Bash will throw<code class="verbatim">readonly variable</code> and abort. If child functions might legitimately need the same name, either drop<code class="verbatim">local -r</code> or use a naming convention that avoids collisions (e.g. prefix with the function name:<code class="verbatim">local -r main_config_path</code>).</li></ul></li><li>Combining declaration and assignment on one line<code class="verbatim">$?</code> to 0, because<code class="verbatim">local</code> itself is a command and it succeeds even when<code class="verbatim">cmd</code> fails.</li></ul></li><li><p><strong>Idempotency:</strong> A "profitable" script should be safe to run multiple times. Some strategies:</p><ul><li>Always recreate/clobber:<code class="verbatim">mkdir -p</code>,<code class="verbatim">touch app.log</code>, fully recreate config files instead of editing in place etc.</li><li>Guard clauses: Check if a configuration line exists before appending it, etc.</li></ul></li></ul></div></div><div id="outline-container-headline-9" class="outline-3"><h3 id="headline-9">
Tackling Readability and Understandability Issues</h3><div id="outline-text-headline-9" class="outline-text-3"><ul><li><strong>Comments:</strong> Document the<em>why</em>, and the expected inputs, outputs, and environment variables of functions. Comment dependencies at the top of the script.</li><li><strong>Long Options:</strong> Use<code class="verbatim">tar --extract</code> instead of<code class="verbatim">tar -x</code>. Long options are self-documenting. See also:<a href="https://rachelbythebay.com/w/2021/10/05/cmd/">rachelbythebay on long args</a>.</li><li><strong>Standard Streams:</strong> Send logs and errors to<code class="verbatim">stderr</code> (<code class="verbatim">&gt;&amp;2</code>) so they don't pollute the data on<code class="verbatim">stdout</code>.</li><li><strong>Reduce obscure features:</strong> Prefer readable constructs over clever one-liners.</li></ul></div></div><div id="outline-container-headline-10" class="outline-3"><h3 id="headline-10">
Blessed Tools</h3><div id="outline-text-headline-10" class="outline-text-3"><p>Set a list of blessed tools that will be used across all your scripts. Ensure that these are installed uniformly across all your environments including dev machines, CI and servers.</p><p>
You may want different blessed tool sets per environment—a developer laptop can have more tools installed than a minimal CI container or a production server. Document each tier so scripts know what they can rely on.</p><p>
These are<em>my</em> blessed tools:</p><ul><li><strong>POSIX shell built-ins:</strong> Prefer built-ins over external commands for portability and performance.</li><li><strong>curl &amp; jq:</strong> The dynamic duo for API interactions and JSON parsing.</li><li><strong>coreutils &amp; moreutils:</strong> Tools like<code class="verbatim">ts</code> (timestamps) and<code class="verbatim">sponge</code> (reading and writing to the same file safely).</li></ul></div></div><div id="outline-container-headline-11" class="outline-3"><h3 id="headline-11">
Unofficial Strict Mode</h3><div id="outline-text-headline-11" class="outline-text-3"><p>Every production script should start with:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">set</span> -o errexit -o nounset -o pipefail</span></span></code></pre></div></div></div></div><div id="outline-container-headline-12" class="outline-3"><h3 id="headline-12">
Debugging</h3><div id="outline-text-headline-12" class="outline-text-3"><div id="outline-container-headline-13" class="outline-4"><h4 id="headline-13">
Syntax Check Without Running</h4><div id="outline-text-headline-13" class="outline-text-4"><p>Use<code class="verbatim">bash -n</code> to check for syntax errors without executing:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">bash -n my-script.sh</span></span></code></pre></div></div></div></div><div id="outline-container-headline-14" class="outline-4"><h4 id="headline-14">
Tracing Execution</h4><div id="outline-text-headline-14" class="outline-text-4"><p><code class="verbatim">set -o xtrace</code> (or<code class="verbatim">set -x</code>) prints each command before running it. Use<code class="verbatim">set +x</code> to limit tracing to a specific section:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">set</span> -x</span></span><span class="line"><span class="cl">some_function<span class="s2">"</span><span class="nv">$arg</span><span class="s2">"</span></span></span><span class="line"><span class="cl"><span class="nb">set</span> +x</span></span></code></pre></div></div><p>
Customize<code class="verbatim">PS4</code> to include the script name, function, and line number in traces:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">export</span><span class="nv">PS4</span><span class="o">=</span><span class="s1">'+(${BASH_SOURCE[0]##*/}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'</span></span></span></code></pre></div></div><p>
To avoid trace output mixing with stderr, redirect it to a dedicated file:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">exec</span><span class="o">{</span>BASH_XTRACEFD<span class="o">}</span>&gt;/tmp/trace.log</span></span><span class="line"><span class="cl"><span class="nb">set</span> -x</span></span></code></pre></div></div></div></div><div id="outline-container-headline-15" class="outline-4"><h4 id="headline-15">
Error Context</h4><div id="outline-text-headline-15" class="outline-text-4"><p>Add a<code class="verbatim">trap</code> on<code class="verbatim">ERR</code> to print the line number whenever a command fails — pairs well with the unofficial strict mode:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">trap</span><span class="s1">'echo "Error on line $LINENO" &gt;&amp;2'</span> ERR</span></span></code></pre></div></div></div></div></div></div><div id="outline-container-headline-16" class="outline-3"><h3 id="headline-16">
Concurrency</h3><div id="outline-text-headline-16" class="outline-text-3"><div id="outline-container-headline-17" class="outline-4"><h4 id="headline-17">
Background Jobs</h4><div id="outline-text-headline-17" class="outline-text-4"><p>Append<code class="verbatim">&amp;</code> to run a command in the background. Use<code class="verbatim">wait</code> to block until all background jobs finish:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">for</span> file in *.log<span class="p">;</span><span class="k">do</span></span></span><span class="line"><span class="cl"> process_file<span class="s2">"</span><span class="nv">$file</span><span class="s2">"</span><span class="p">&amp;</span></span></span><span class="line"><span class="cl"><span class="k">done</span></span></span><span class="line"><span class="cl">wait</span></span></code></pre></div></div><p>
To catch failures, capture each job's PID with<code class="verbatim">$!</code> and wait on it explicitly:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">cmd1<span class="p">&amp;</span><span class="nv">pid1</span><span class="o">=</span><span class="nv">$!</span></span></span><span class="line"><span class="cl">cmd2<span class="p">&amp;</span><span class="nv">pid2</span><span class="o">=</span><span class="nv">$!</span></span></span><span class="line"><span class="cl"><span class="nb">wait</span><span class="s2">"</span><span class="nv">$pid1</span><span class="s2">"</span><span class="o">||</span> log_error<span class="s2">"cmd1 failed"</span></span></span><span class="line"><span class="cl"><span class="nb">wait</span><span class="s2">"</span><span class="nv">$pid2</span><span class="s2">"</span><span class="o">||</span> log_error<span class="s2">"cmd2 failed"</span></span></span></code></pre></div></div><p>
For CPU-bound work, cap parallelism with<code class="verbatim">xargs -P</code>:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">printf</span><span class="s1">'%s\n'</span> *.log<span class="p">|</span> xargs -P4 -I<span class="o">{}</span> process_file<span class="o">{}</span></span></span></code></pre></div></div></div></div><div id="outline-container-headline-18" class="outline-4"><h4 id="headline-18">
Preventing Concurrent Execution</h4><div id="outline-text-headline-18" class="outline-text-4"><p>Use<code class="verbatim">flock</code> to ensure only one instance of a script runs at a time — essential for cron jobs and shared automation:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">exec</span> 9&gt;/var/lock/my-script.lock</span></span><span class="line"><span class="cl">flock --nonblock<span class="m">9</span><span class="o">||</span><span class="o">{</span> log_error<span class="s2">"Another instance is already running."</span><span class="p">;</span><span class="nb">exit</span> 1<span class="p">;</span><span class="o">}</span></span></span></code></pre></div></div><p>
The lock is released automatically when the script exits or crashes, so no cleanup is needed.</p></div></div></div></div><div id="outline-container-headline-19" class="outline-3"><h3 id="headline-19">
A Few Other Recommendations</h3><div id="outline-text-headline-19" class="outline-text-3"><ul><li>Check the Bash version at runtime if you rely on version-specific features.</li><li>Check that required tools are installed before using them.</li></ul></div></div><div id="outline-container-headline-20" class="outline-3"><h3 id="headline-20">
A Bit More Paranoia</h3><div id="outline-text-headline-20" class="outline-text-3"><ul><li>Check versions of tools, not just their presence.</li><li>Check available disk space before writing large files.</li><li>Check permissions on files before reading or modifying them.</li></ul></div></div><div id="outline-container-headline-21" class="outline-3"><h3 id="headline-21">
Scripting with LLMs</h3><div id="outline-text-headline-21" class="outline-text-3"><p>LLMs meaningfully change the tradeoffs around Bash. One of the strongest arguments against it was the arcane syntax: cryptic special variables like<code class="verbatim">$IFS</code>,<code class="verbatim">$*</code>, and<code class="verbatim">&lt;()</code>, short flags, and obscure built-ins are hard to read and even harder to look up. You can now paste a line you don't understand into an LLM and get an explanation in seconds.<sup class="footnote-reference"><a id="footnote-reference-11" href="#footnote-11">11</a></sup></p><div id="outline-container-headline-22" class="outline-4"><h4 id="headline-22">
Helping Agents Work in Your Repo</h4><div id="outline-text-headline-22" class="outline-text-4"><p>LLMs confidently produce subtly incorrect quoting, miss<code class="verbatim">pipefail</code> edge cases, or generate code that works on GNU but fails on BSD. If you use coding agents in a repository that contains shell scripts, create an<code class="verbatim">AGENTS.md</code> (or<code class="verbatim">CLAUDE.md</code> for Claude Code) at the root. Document:</p><ul><li>Which shell is expected (<code class="verbatim">bash</code>, POSIX<code class="verbatim">sh</code>, etc.) and the minimum version.</li><li>Conventions: long options, quoting style, logging functions.</li><li>How to validate scripts (e.g.<code class="verbatim">shellcheck *.sh</code>).</li><li>How to run tests if you use<a href="https://github.com/bats-core/bats-core">BATS</a>.</li></ul><p>From this article, the blessed tools list, and the unofficial strict mode line are all worth copying verbatim into your<code class="verbatim">AGENTS.md</code>.</p><p>
Example:</p><div class="src src-markdown"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl"><span class="gu">## Shell Scripts</span></span></span><span class="line"><span class="cl"><span class="k">-</span> Use Bash 4+. All scripts must pass<span class="sb">`shellcheck`</span>.</span></span><span class="line"><span class="cl"><span class="k">-</span> Use long options (<span class="sb">`--verbose`</span>, not<span class="sb">`-v`</span>) for readability.</span></span><span class="line"><span class="cl"><span class="k">-</span> Source<span class="sb">`lib/logging.sh`</span> for log_info / log_error.</span></span><span class="line"><span class="cl">- Run tests:<span class="sb">`bats tests/`</span></span></span></code></pre></div></div><hr/></div></div></div></div></div><div id="outline-container-headline-23" class="outline-2"><h2 id="headline-23">
The "Pro-Profit" Template</h2><div id="outline-text-headline-23" class="outline-text-2"><p>If you are writing a script for a production environment, don't start
from a blank file. Use a template that handles the "boring stuff" like
logging, cleanup, and error handling.</p><p>
NOTE: This template was generated by Claude Code after examining my current scripts and then manually reviewed.</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="cp">#!/usr/bin/env bash</span></span></span><span class="line"><span class="cl"><span class="c1"># Env shebang is especially useful on macOS where newer versions of Bash are installed via Homebrew.</span></span></span><span class="line"><span class="cl"/></span><span class="line"><span class="cl"><span class="c1"># --- Unofficial Strict Mode ---</span></span></span><span class="line"><span class="cl"><span class="nb">set</span> -o errexit<span class="c1"># Exit on error</span></span></span><span class="line"><span class="cl"><span class="nb">set</span> -o nounset<span class="c1"># Exit on unset variables</span></span></span><span class="line"><span class="cl"><span class="nb">set</span> -o pipefail<span class="c1"># Catch errors in pipelines</span></span></span><span class="line"><span class="cl"/></span><span class="line"><span class="cl"><span class="c1"># `set -o errexit -o nounset -o pipefail` is my preferred form</span></span></span><span class="line"><span class="cl"><span class="c1"># `set -euxo pipefail` incantation fails my readability check.</span></span></span><span class="line"><span class="cl"/></span><span class="line"><span class="cl"><span class="c1"># --- Constants &amp; Global Variables ---</span></span></span><span class="line"><span class="cl"><span class="nv">SCRIPT_NAME</span><span class="o">=</span><span class="k">$(</span>basename<span class="s2">"</span><span class="nv">$0</span><span class="s2">"</span><span class="k">)</span></span></span><span class="line"><span class="cl"><span class="nb">readonly</span> SCRIPT_NAME</span></span><span class="line"><span class="cl"><span class="nv">TMP_DIR</span><span class="o">=</span><span class="k">$(</span>mktemp -d<span class="s2">"</span><span class="si">${</span><span class="nv">TMPDIR</span><span class="k">:-</span><span class="p">/tmp</span><span class="si">}</span><span class="s2">/</span><span class="si">${</span><span class="nv">SCRIPT_NAME</span><span class="si">}</span><span class="s2">.XXXXXX"</span><span class="k">)</span></span></span><span class="line"><span class="cl"><span class="nb">readonly</span> TMP_DIR</span></span><span class="line"><span class="cl"/></span><span class="line"><span class="cl"><span class="c1"># --- Cleanup Logic ---</span></span></span><span class="line"><span class="cl"><span class="c1"># Trap signals to ensure temporary files are deleted even on crash/interrupt</span></span></span><span class="line"><span class="cl">cleanup<span class="o">()</span><span class="o">{</span></span></span><span class="line"><span class="cl"> rm -rf<span class="s2">"</span><span class="nv">$TMP_DIR</span><span class="s2">"</span></span></span><span class="line"><span class="cl"> log_info<span class="s2">"Cleanup complete. Temp files removed."</span></span></span><span class="line"><span class="cl"><span class="o">}</span></span></span><span class="line"><span class="cl"><span class="nb">trap</span> cleanup EXIT</span></span><span class="line"><span class="cl"/></span><span class="line"><span class="cl"><span class="c1"># --- Logging Functions ---</span></span></span><span class="line"><span class="cl"><span class="c1"># Send all logs to stderr so stdout stays clean for data</span></span></span><span class="line"><span class="cl"><span class="c1"># TODO: Consider supporting NO_COLOR</span></span></span><span class="line"><span class="cl">log_info<span class="o">()</span><span class="o">{</span><span class="nb">printf</span><span class="s2">"\e[32m[INFO]\e[0m %s\n"</span><span class="s2">"</span><span class="nv">$*</span><span class="s2">"</span> &gt;<span class="p">&amp;</span>2<span class="p">;</span><span class="o">}</span></span></span><span class="line"><span class="cl">log_error<span class="o">()</span><span class="o">{</span><span class="nb">printf</span><span class="s2">"\e[31m[ERROR]\e[0m %s\n"</span><span class="s2">"</span><span class="nv">$*</span><span class="s2">"</span> &gt;<span class="p">&amp;</span>2<span class="p">;</span><span class="o">}</span></span></span><span class="line"><span class="cl"/></span><span class="line"><span class="cl"><span class="c1"># --- Usage Function ---</span></span></span><span class="line"><span class="cl">usage<span class="o">()</span><span class="o">{</span></span></span><span class="line"><span class="cl"> cat<span class="s">&lt;&lt;EOF</span></span></span><span class="line"><span class="cl"><span class="s">Usage: ${SCRIPT_NAME} [options] &lt;input_file&gt;</span></span></span><span class="line"><span class="cl"><span class="s"/></span></span><span class="line"><span class="cl"><span class="s">Options:</span></span></span><span class="line"><span class="cl"><span class="s"> -h, --help Display this help message</span></span></span><span class="line"><span class="cl"><span class="s"> -v, --verbose Enable verbose logging</span></span></span><span class="line"><span class="cl"><span class="s"/></span></span><span class="line"><span class="cl"><span class="s">Example:</span></span></span><span class="line"><span class="cl"><span class="s"> ${SCRIPT_NAME} --verbose data.txt</span></span></span><span class="line"><span class="cl"><span class="s">EOF</span></span></span><span class="line"><span class="cl"><span class="nb">exit</span><span class="m">1</span></span></span><span class="line"><span class="cl"><span class="o">}</span></span></span><span class="line"><span class="cl"/></span><span class="line"><span class="cl"><span class="c1"># --- Argument Parsing ---</span></span></span><span class="line"><span class="cl">parse_params<span class="o">()</span><span class="o">{</span></span></span><span class="line"><span class="cl"> :</span></span><span class="line"><span class="cl"><span class="c1"># TODO: Implement actual parsing logic.</span></span></span><span class="line"><span class="cl"><span class="o">}</span></span></span><span class="line"><span class="cl"/></span><span class="line"><span class="cl"><span class="c1"># --- Main Logic ---</span></span></span><span class="line"><span class="cl">main<span class="o">()</span><span class="o">{</span></span></span><span class="line"><span class="cl"> parse_params<span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span></span></span><span class="line"><span class="cl"/></span><span class="line"><span class="cl"> log_info<span class="s2">"Starting script execution..."</span></span></span><span class="line"><span class="cl"> log_info<span class="s2">"Working in temporary directory:</span><span class="si">${</span><span class="nv">TMP_DIR</span><span class="si">}</span><span class="s2">"</span></span></span><span class="line"><span class="cl"/></span><span class="line"><span class="cl"><span class="c1"># Your logic goes here...</span></span></span><span class="line"><span class="cl"><span class="o">}</span></span></span><span class="line"><span class="cl"/></span><span class="line"><span class="cl">main<span class="s2">"</span><span class="nv">$@</span><span class="s2">"</span></span></span></code></pre></div></div><hr/></div><div id="outline-container-headline-24" class="outline-2"><h2 id="headline-24">
Common Pitfalls and Workarounds</h2><div id="outline-text-headline-24" class="outline-text-2"><ul><li><strong>Spaces around assignment:</strong> Use<code class="verbatim">VAR=1</code>, not<code class="verbatim">VAR = 1</code>.</li><li><strong>Sponge on files:</strong> Avoid truncating files by using<code class="verbatim">sponge</code> from moreutils when reading and writing to the same file.</li><li><strong>Shellcheck &amp; Shellharden:</strong> Never ship a script without running it through<a href="https://www.shellcheck.net/">Shellcheck</a>. Consider<a href="https://github.com/anordal/shellharden">Shellharden</a> for auto-fixing quoting issues.</li></ul></div></div><div id="outline-container-headline-25" class="outline-2"><h2 id="headline-25">
A Note About POSIX Compatibility</h2><div id="outline-text-headline-25" class="outline-text-2"><p>While POSIX compliance ensures maximum portability, it is often harder to write safely. Since Bash is nearly universal in modern DevOps environments, it is usually better to leverage Bash-specific features for safety (like<code class="verbatim">[[</code> and arrays) unless you specifically target minimal environments like Alpine (Ash) or BusyBox.</p></div></div><div id="outline-container-headline-26" class="outline-2"><h2 id="headline-26">
Examples</h2><div id="outline-text-headline-26" class="outline-text-2"><ul><li><a href="https://gitlab.com/gitlab-org/cluster-integration/auto-deploy-image/-/blob/master/src/bin/auto-deploy">GitLab Auto Deploy</a></li><li><a href="https://github.com/bitnami/containers/tree/main/bitnami/postgresql/16/debian-12/rootfs/opt/bitnami/scripts">Bitnami Container Scripts</a></li><li><a href="https://github.com/bitnami/containers/blob/main/bitnami/neo4j/5/debian-12/prebuildfs/opt/bitnami/scripts/liblog.sh">Bitnami Neo4j liblog.sh</a></li><li><a href="https://clickhouse.com">Clickhouse Install</a> (<code class="verbatim">curl</code> it to see).</li><li><a href="https://get.volta.sh/">Volta Install Script</a></li></ul></div></div><div id="outline-container-headline-27" class="outline-2"><h2 id="headline-27">
Misc. Tips</h2><div id="outline-text-headline-27" class="outline-text-2"><div id="outline-container-headline-28" class="outline-3"><h3 id="headline-28">
Make Anything Executable</h3><div id="outline-text-headline-28" class="outline-text-3"><p>You can use any binary as a script interpreter with a shebang. For example, to use a Kubernetes manifest as an executable:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1">#!/usr/bin/env -S istioctl upgrade --verify --filename</span></span></span></code></pre></div></div></div></div><div id="outline-container-headline-29" class="outline-3"><h3 id="headline-29">
Python Scripts with<code class="verbatim">uv</code></h3><div id="outline-text-headline-29" class="outline-text-3"><p><a href="https://docs.astral.sh/uv/">uv</a> makes Python scripts behave more like shell scripts. Use<code class="verbatim">uvx</code> to run a tool without installing it:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">uvx ruff check .</span></span></code></pre></div></div><p>
For scripts with dependencies, use a<code class="verbatim">uv run</code> shebang with<a href="https://peps.python.org/pep-0723/">PEP 723</a> inline metadata:</p><div class="src src-python"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="ch">#!/usr/bin/env -S uv run --script</span></span></span><span class="line"><span class="cl"><span class="c1"># /// script</span></span></span><span class="line"><span class="cl"><span class="c1"># dependencies = ["requests"]</span></span></span><span class="line"><span class="cl"><span class="c1"># ///</span></span></span><span class="line"><span class="cl"><span class="kn">import</span><span class="nn">requests</span></span></span><span class="line"><span class="cl"><span class="o">...</span></span></span></code></pre></div></div><p><code class="verbatim">uv</code> resolves and caches the virtualenv on first run. The script is self-contained and portable to any machine with<code class="verbatim">uv</code> installed.</p></div></div><div id="outline-container-headline-30" class="outline-3"><h3 id="headline-30">
An Installation Strategy</h3><div id="outline-text-headline-30" class="outline-text-3"><ul><li>Your tool has an install command that does the actual installation.</li><li>A shell script just figures out the version to download, downloads the binary, and executes it.</li></ul></div></div><div id="outline-container-headline-31" class="outline-3"><h3 id="headline-31">
Date</h3><div id="outline-text-headline-31" class="outline-text-3"><p>Use the ISO 8601 format for log timestamps:</p><div class="src src-bash"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">date --iso-8601<span class="o">=</span>seconds</span></span></code></pre></div></div><p>The above command is a classic example of inconsistency across BSD and GNU. You'll have to use something like<code class="verbatim">date +'%Y-%m-%dT%H:%M:%S%z'</code> for it to work across macOS and Linux.</p></div></div></div></div><div id="outline-container-headline-32" class="outline-2"><h2 id="headline-32">
A Reading List</h2><div id="outline-text-headline-32" class="outline-text-2"><div id="outline-container-headline-33" class="outline-3"><h3 id="headline-33">
Learning Bash</h3><div id="outline-text-headline-33" class="outline-text-3"><ul><li><a href="https://hyperpolyglot.org/unix-shells">Unix Shells</a>: A summary of the features of various Unix shells such as Bash, Fish, Ksh, and Zsh.</li><li><a href="https://v4.software-carpentry.org/shell/index.html">Software Carpentry: The Unix Shell</a>: Extremely beginner-friendly introduction to the shell.</li><li><a href="https://earthly.dev/blog/bash-variables/">Understanding Bash Variables</a></li><li><a href="https://blog.balthazar-rouberol.com/text-processing-in-the-shell">Text Processing in the Shell</a>: Commonly available Unix tools for text processing.</li><li><a href="https://web.archive.org/web/20210916210855/http://cb.vu/unixtoolbox.xhtml">Unix Tools</a>: Concise coverage of Unix tools.</li></ul></div></div><div id="outline-container-headline-34" class="outline-3"><h3 id="headline-34">
Learning POSIX Sh</h3><div id="outline-text-headline-34" class="outline-text-3"><ul><li><a href="https://www.grymoire.com/Unix/Sh.html">Grymoire's Tutorial on the POSIX Shell</a>: A comprehensive POSIX shell tutorial. Grymoire also has excellent tutorials on<a href="https://www.grymoire.com/Unix/Regular.html">Regular Expressions</a>.</li></ul></div></div><div id="outline-container-headline-35" class="outline-3"><h3 id="headline-35">
Pitfalls</h3><div id="outline-text-headline-35" class="outline-text-3"><ul><li><a href="https://wiki.bash-hackers.org/scripting/newbie_traps">Beginner Mistakes</a>: Typical beginner mistakes while writing Bash scripts.</li><li><a href="http://mywiki.wooledge.org/BashPitfalls">Bash Pitfalls</a>: A collection of common Bash mistakes.</li><li><a href="http://www.pixelbeat.org/programming/shell_script_mistakes.html">Shell Script Mistakes</a></li><li><a href="https://blog.janestreet.com/when-bash-scripts-bite/">When Bash Scripts Bite</a>: An unexpected issue with the unofficial strict mode.</li><li><a href="https://thomask.sdf.org/blog/2019/11/09/take-care-editing-bash-scripts.html">Take Care Editing Bash Scripts</a>: What happens when you edit a running script.</li><li><a href="https://rachelbythebay.com/w/2020/08/11/files/">File Handling in Unix</a>: Pitfalls and tips surrounding file handling.</li></ul></div></div><div id="outline-container-headline-36" class="outline-3"><h3 id="headline-36">
Writing Better Bash</h3><div id="outline-text-headline-36" class="outline-text-3"><ul><li><a href="https://jonlabelle.com/snippets/view/markdown/defensive-bash-programming">Defensive BASH Programming</a>: A well-commented template for defensive bash scripts.</li><li><a href="https://zwischenzugs.com/2018/01/06/ten-things-i-wish-id-known-about-bash/">Ten Things I Wish I'd Known About Bash</a></li><li><a href="https://saveriomiroddi.github.io/Additional-shell-options-for-non-trivial-bash-shell-scripts/">Additional Shell Options for Non-Trivial Scripts</a>: An extension to the unofficial strict mode.</li><li><a href="https://github.com/anordal/shellharden/blob/master/how_to_do_things_safely_in_bash.md">Safe Ways to Do Things in Bash</a></li><li><a href="https://www.davidpashley.com/articles/writing-robust-shell-scripts/">Writing Robust Bash Shell Scripts</a></li><li><a href="https://blog.yossarian.net/2020/01/23/Anybody-can-write-good-bash-with-a-little-effort">Anybody Can Write Good Bash</a></li><li><a href="https://google.github.io/styleguide/shellguide.html">Google Shell Style Guide</a></li></ul></div></div><div id="outline-container-headline-37" class="outline-3"><h3 id="headline-37">
Snippets</h3><div id="outline-text-headline-37" class="outline-text-3"><ul><li><a href="http://www.etalabs.net/sh_tricks.html">Rich's sh (POSIX shell) tricks</a>: A collection of POSIX sh snippets for common tasks.</li><li><a href="https://github.com/dylanaraps/pure-bash-bible">Pure Bash Bible</a> and<a href="https://github.com/dylanaraps/pure-sh-bible">Pure Sh Bible</a>: Pure bash/sh alternatives to external processes.</li><li><a href="https://github.com/onceupon/Bash-Oneliner">Bash-Oneliner</a>: Handy Bash one-liners for data processing and system maintenance.</li></ul></div></div><div id="outline-container-headline-38" class="outline-3"><h3 id="headline-38">
Miscellaneous</h3><div id="outline-text-headline-38" class="outline-text-3"><ul><li><a href="https://en.wikipedia.org/wiki/List_of_GNU_Core_Utilities_commands">List of GNU Core Utilities Commands</a></li><li><a href="https://github.com/denysdovhan/bash-handbook">Bash Handbook</a></li><li><p><a href="https://joeyh.name/code/moreutils/">Moreutils</a>: "A collection of the unix tools that nobody thought to write long ago when unix was young."</p><ul><li>I heavily use of<code class="verbatim">ts</code> (like<code class="verbatim">ping 8.8.8.8 | ts "%Y-%m-%dT%H:%M:%S%Z"</code>) and<code class="verbatim">vipe</code>.</li></ul></li><li><a href="https://catonmat.net/bash-functions">Something You Didn't Know About Functions in Bash</a></li><li><a href="https://github.com/bats-core/bats-core">BATS (Bash Automated Testing System)</a></li></ul><hr/></div></div></div><div id="outline-container-headline-39" class="outline-2"><h2 id="headline-39">
Footnotes</h2></div><div class="footnotes"><hr class="footnotes-separatator"/><div class="footnote-definitions"><div class="footnote-definition"><sup id="footnote-1"><a href="#footnote-reference-1">1</a></sup><div class="footnote-body"><p>For about five years now, which is not all that long considering bash is over three decades old.</p></div></div><div class="footnote-definition"><sup id="footnote-2"><a href="#footnote-reference-2">2</a></sup><div class="footnote-body"><p>This article is mostly about Bash Scripting but my points should generalize to other Shells too.</p></div></div><div class="footnote-definition"><sup id="footnote-3"><a href="#footnote-reference-3">3</a></sup><div class="footnote-body"><p>I started writing this article over a year ago and sat on it for a while. The two most meaningful changes in the landscape since then:<a href="https://docs.astral.sh/uv/">uv</a>, which makes Python a much more practical scripting language, and LLMs, which dramatically reduce the friction of understanding arcane Bash syntax.</p></div></div><div class="footnote-definition"><sup id="footnote-4"><a href="#footnote-reference-4">4</a></sup><div class="footnote-body"><p><a href="http://catb.org/~esr/writings/unix-koans/ten-thousand.html">Master Foo and the Ten Thousand Lines</a></p></div></div><div class="footnote-definition"><sup id="footnote-5"><a href="#footnote-reference-5">5</a></sup><div class="footnote-body"><p><a href="http://www.leancrew.com/all-this/2011/12/more-shell-less-egg/">Knuth vs McIlroy</a></p></div></div><div class="footnote-definition"><sup id="footnote-6"><a href="#footnote-reference-6">6</a></sup><div class="footnote-body"><p>Most Linux distributions ship GNU coreutils, while macOS ships BSD-derived tools. The two often differ in flag names, default behaviours, and supported options — for example,<code class="verbatim">date --iso-8601</code> works on GNU but not on BSD<code class="verbatim">date</code>. FreeBSD, OpenBSD, and NetBSD also ship BSD tools. If your scripts must run on both Linux and macOS, either install GNU coreutils on macOS (via Homebrew:<code class="verbatim">brew install coreutils</code>) or write to the lowest common denominator using POSIX-specified behaviour only.</p></div></div><div class="footnote-definition"><sup id="footnote-7"><a href="#footnote-reference-7">7</a></sup><div class="footnote-body"><p><a href="https://knowyourmeme.com/memes/roll-safe">You won't have any bad bash scripts if you don't write bash</a></p></div></div><div class="footnote-definition"><sup id="footnote-8"><a href="#footnote-reference-8">8</a></sup><div class="footnote-body"><p>Libraries like<a href="https://hackage.haskell.org/package/turtle">Turtle</a> and<a href="https://hackage.haskell.org/package/shelly">Shelly</a> give Haskell a pipeline-friendly scripting style. Because Haskell's type inference covers the whole program without much annotation, scripts stay concise while the compiler catches errors — wrong path types, malformed date strings — that Bash would only surface at runtime.</p></div></div><div class="footnote-definition"><sup id="footnote-9"><a href="#footnote-reference-9">9</a></sup><div class="footnote-body"><p>Since Java 11, single-file programs run directly with<code class="verbatim">java MyScript.java</code>, no explicit compilation step needed. Java 21+ goes further: unnamed classes and instance<code class="verbatim">main</code> methods (<a href="https://openjdk.org/jeps/445">JEP 445</a>) drop the<code class="verbatim">public class</code> and<code class="verbatim">public static void main</code> boilerplate, making small programs look much more like scripts.<a href="https://www.jbang.dev/">JBang</a> adds a shebang line and inline dependency declarations on top of this, making it practical to reuse existing Java libraries and share logic with Java-based services.</p></div></div><div class="footnote-definition"><sup id="footnote-10"><a href="#footnote-reference-10">10</a></sup><div class="footnote-body"><p><a href="https://jupyter.org/">Jupyter</a> notebooks are the standard for iterative, exploratory work.<a href="https://papermill.io/">Papermill</a> takes this further by letting you parameterise and execute notebooks as pipeline steps — useful when you want the interactivity of a notebook during development but repeatable, auditable runs in production.</p></div></div><div class="footnote-definition"><sup id="footnote-11"><a href="#footnote-reference-11">11</a></sup><div class="footnote-body"><p><a href="https://explainshell.com/">explainshell.com</a> predates LLMs and does one thing well: paste any shell command and it annotates each flag and argument against the relevant man page. Still useful for a quick, authoritative breakdown without the hallucination risk.</p></div></div></div></div>
]]></content></entry><entry><title>Writing Issue-Fixing Documentation That Actually Fixes Issues</title><link href="/blog/post/bug-fixing-docs/" rel="alternate" type="text/html"/><id>/blog/post/bug-fixing-docs/</id><updated>2026-02-28T00:54:59+05:30</updated><published>2026-02-28T00:54:59+05:30</published><author><name>[npalladium A Dev Tired of Debugging Docs A Programmer Who Finally Read Their Own Docs]</name></author><content type="html">&lt;![CDATA[<div id="outline-container-headline-1" class="outline-2"><h2 id="headline-1">
The Iron Triangle of Fix Documentation</h2><div id="outline-text-headline-1" class="outline-text-2"><p>Every issue-fixing document must contain these three elements, or you're just publishing creative fiction:</p><div id="outline-container-headline-2" class="outline-3"><h3 id="headline-2">
Pre-Flight Check: Confirming You Have the Right Problem</h3><div id="outline-text-headline-2" class="outline-text-3"><p>Before users start running commands they found on Stack Overflow, make them verify they actually have the issue your doc addresses. Include:</p><ul><li>Specific error messages to search for</li><li>Symptoms that distinguish this from similar issues</li><li>Version numbers, environment details, or configuration states</li></ul><p>Remember what every old hand knows: Half of support tickets are people applying the wrong fix to the right problem. The other half are people applying the right fix to the wrong problem.</p></div></div><div id="outline-container-headline-3" class="outline-3"><h3 id="headline-3">
Post-Mortem: Proving the Fix Actually Worked</h3><div id="outline-text-headline-3" class="outline-text-3"><p>Changes don't always take hold immediately. Caches exist. Services need restarts. The universe is indifferent to your deployment.</p><p>
Provide clear verification steps:</p><ul><li>What output/behavior should change</li><li>How long to wait before panicking</li><li>Common reasons the fix might not apply (caching, permissions, phase of moon)</li></ul><p>The person following your doc should never have to wonder "did it work?" They should<strong>know</strong>.</p></div></div><div id="outline-container-headline-4" class="outline-3"><h3 id="headline-4">
The Escape Hatch: Reverting Your Mess</h3><div id="outline-text-headline-4" class="outline-text-3"><p>Nothing strikes fear like "irreversible changes." Give users:</p><ul><li>Explicit revert instructions</li><li>Which changes are reversible vs permanent</li><li>What they should backup before starting</li></ul><p>Sometimes these steps are obvious, sometimes they are not. Sometimes you think they are obvious, but they are not.</p><p>
If you can't provide revert steps, start your doc with "POINT OF NO RETURN AHEAD"</p></div></div></div></div><div id="outline-container-headline-5" class="outline-2"><h2 id="headline-5">
Bonus Points: Separating Good Docs from Great Docs</h2><div id="outline-text-headline-5" class="outline-text-2"><ul><li><strong>Prerequisites</strong>: Required permissions, tools, access levels, or ritual sacrifices</li><li><strong>Breaking Changes</strong>: "Fixing X will break Y" belongs at the<strong>top</strong> of your doc, not buried in paragraph seven. Users who discover downstream breakage after applying your fix will remember you, and not fondly.</li><li><strong>External References</strong>: Link to relevant docs, upstream issues, RFCs, or the blog post that caused this mess in the first place.</li><li><strong>Sanity Checks Throughout</strong>: Add verification steps between major operations. Let users catch mistakes early rather than at the catastrophic finale.</li><li><strong>Troubleshooting Section</strong>: "If Step 3 fails with error X, try Y"</li><li><strong>Related Issues and Rabbit Holes</strong>: Link to similar issues that might be confused with this one. Save future-you from explaining the difference for the hundredth time.</li><li><strong>Common Pitfalls</strong>: The mistakes 80% of people make when following this doc</li><li><strong>Time Estimates</strong>: How long each step takes (including waiting for DNS propagation until heat death of universe)</li><li><strong>Here be dragons:</strong> Doing something high technical, poking into internals or using some software in a way it was not intended? Mark it down.</li></ul></div></div><div id="outline-container-headline-6" class="outline-2"><h2 id="headline-6">
Conclusion</h2><div id="outline-text-headline-6" class="outline-text-2"><p>Good fix documentation is like good code: it handles edge cases, provides clear feedback, and doesn't leave users wondering what just happened.</p><p>
Bad fix documentation is also like bad code: it assumes a perfect world, fails silently, and generates technical debt in the form of confused users and repeat tickets (or even worse completely NEW tickets caused by it).</p><p>
Write the doc you'd be okay with sending to a psychopath who knows your address.</p></div></div>
]]></content></entry><entry><title>About</title><link href="/blog/about/" rel="alternate" type="text/html"/><id>/blog/about/</id><updated>2026-02-27T23:55:25+05:30</updated><published>2026-02-27T23:55:25+05:30</published><author><name>n</name></author><content type="html">&lt;![CDATA[<p>Welcome to a small corner of the internet where the READMEs are rhapsodic and the poetry is pull-requested.</p>
]]></content></entry><entry><title>Hello, World</title><link href="/blog/post/hello-world/" rel="alternate" type="text/html"/><id>/blog/post/hello-world/</id><updated>2026-02-27T23:55:25+05:30</updated><published>2026-02-27T23:55:25+05:30</published><author><name>npalladium</name></author><category term="fibonacci"/><category term="math"/><category term="poetry"/><content type="html">&lt;![CDATA[<p>
Welcome to the blog.</p><div id="outline-container-headline-1" class="outline-2"><h2 id="headline-1">
Code</h2><div id="outline-text-headline-1" class="outline-text-2"><div class="src src-python"><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span><span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">):</span></span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span></span></span><span class="line"><span class="cl"><span class="k">while</span><span class="n">a</span><span class="o">&lt;</span><span class="n">n</span><span class="p">:</span></span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s1">' '</span><span class="p">)</span></span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="o">=</span><span class="n">b</span><span class="p">,</span><span class="n">a</span><span class="o">+</span><span class="n">b</span></span></span></code></pre></div></div></div></div><div id="outline-container-headline-2" class="outline-2"><h2 id="headline-2">
Math</h2><div id="outline-text-headline-2" class="outline-text-2"><p>
$$
\varphi = \frac{1 + \sqrt{5}}{2} = 1 + \cfrac{1}{1 + \cfrac{1}{1 + \cfrac{1}{1 + \cdots}}}
$$</p></div></div><div id="outline-container-headline-3" class="outline-2"><h2 id="headline-3">
Poetry</h2><div id="outline-text-headline-3" class="outline-text-2"><blockquote><p>One</p><p>
Small,</p><p>
Precise,</p><p>
Poetic,</p><p>
Spiraling mixture:</p><p>
Math plus poetry yields the Fib.</p></blockquote><p>
— Pincus, Gregory K.</p></div></div>
]]></content></entry></feed>